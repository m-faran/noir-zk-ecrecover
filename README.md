# Noir ZK ECRecover 🔐

A zero-knowledge proof implementation of ECDSA signature verification using Noir, demonstrating how to verify Ethereum signatures in a privacy-preserving manner without revealing the actual signature or message.

## Overview 🌟

This project showcases the implementation of elliptic curve signature recovery (ECRecover) using Noir's zero-knowledge proof system. It allows verification that a signature is valid for a given public key and message hash without revealing the signature itself, enabling privacy-preserving authentication and authorization mechanisms.

### Key Features

- **Zero-Knowledge ECDSA Verification** - Verify signatures without revealing them
- **Ethereum Compatibility** - Works with standard Ethereum ECDSA signatures
- **Privacy-Preserving** - Hide sensitive signature data while proving validity
- **Noir Integration** - Leverages Noir's elliptic curve primitives
- **Educational Example** - Demonstrates ZK cryptography concepts in practice

## Use Cases 💡

- **Private Authentication** - Prove identity without revealing credentials
- **Anonymous Voting** - Verify voter eligibility without exposing identity
- **Confidential Transactions** - Authorize payments without revealing details
- **ZK Identity Systems** - Build privacy-first authentication systems
- **Regulatory Compliance** - Prove compliance without revealing sensitive data

## Technology Stack 🛠️

- **Noir** - Domain-specific language for zero-knowledge circuits
- **Nargo** - Noir's build tool and package manager
- **Barretenberg** - Proving backend for generating ZK proofs

## Project Structure 📁

```
noir-zk-ecrecover/
├── src/
│   └── main.nr           # Main Noir circuit implementation
├── Nargo.toml            # Project configuration and dependencies
├── Prover.toml           # Test signature and input data
├── target/               # Build artifacts (generated)
│   ├── *.json           # Circuit compilation output
│   ├── *.gz             # Witness files
│   ├── proof            # Generated ZK proof
│   ├── vk               # Verification key
│   └── public_inputs    # Public circuit inputs       
└── README.md 
```                    

## 🚨 Security Warning

**IMPORTANT: This repository contains test data from Anvil (local Ethereum testnet)**

The `Prover.toml` file includes signatures, private keys, and wallet addresses that are **ONLY FOR TESTING PURPOSES**. These are generated by Anvil's deterministic test accounts and are publicly known.

### ⚠️ Never Use Real Wallet Data

**DO NOT use your real wallet's private keys, signatures, or addresses in this or any public repository.**

Here's why this is dangerous:

- **Private Key Exposure** - Anyone can access your funds with your private key
- **Signature Replay** - Exposed signatures can be used maliciously
- **Address Linking** - Public addresses can be linked to your identity
- **Permanent Record** - Git history preserves data even after deletion
- **Automated Scanning** - Bots constantly scan GitHub for exposed keys

### Safe Practices 🔒

- Always use test networks (Anvil, Sepolia, Goerli) for development
- Use environment variables for sensitive data in local development
- Never commit `.env` files or private keys to version control
- Use hardware wallets for real funds
- Regularly rotate test keys and addresses

**IMPORTANT: This repo is built for educational purposes only. Dont use in production as the dependency `ecrecover` contains vulnerable code**

## Getting Started 🚀

### Prerequisites

Ensure you have the following installed:

- **Nargo** (Noir's package manager)
- **Barretenberg** (bb) for proof generation
- **Git** for cloning the repository

### Installation

#### 1. Install noirup and bbup (if not already installed)

Refer to noir lanuage docs...

#### 2. Verify Installation
```bash
nargo --version
bb --version
```

### Quick Start

**Clone the Repository**
   ```bash
   git clone https://github.com/m-faran/noir-zk-ecrecover.git
   cd noir-zk-ecrecover
   ```

## How It Works 🔍

### Circuit Logic

The Noir circuit implements ECDSA signature verification by:

1. **Input Processing** - Takes signature components (r, s, v), message hash, and expected public key
2. **Point Recovery** - Recovers the public key from the signature using elliptic curve operations
3. **Verification** - Compares the recovered public key with the expected one
4. **Constraint Generation** - Creates mathematical constraints that prove signature validity

### Mathematical Foundation

The circuit leverages the mathematical properties of elliptic curves:
- **Signature Components**: `(r, s, v)` where `r` and `s` are signature values, `v` is recovery parameter
- **Message Hash**: Keccak256 hash of the original message
- **Public Key Recovery**: Uses elliptic curve point addition and scalar multiplication
- **Verification**: Proves that the signature was created by the holder of the private key

## Example Use Case 🎯

This implementation can be used for:

```rust
// Pseudocode example
let signature = sign_message(private_key, "Hello, World!");
let proof = generate_zk_proof(signature, message_hash, public_key);

// Verifier can confirm signature validity without seeing the signature
assert(verify_proof(proof, message_hash, public_key) == true);
```

## Performance Characteristics 📊

- **Circuit Size**: ~X constraints (depends on implementation)
- **Proving Time**: ~X seconds (varies by hardware)
- **Proof Size**: ~X KB (standard for Noir proofs)
- **Verification Time**: ~X milliseconds

## Contributing 🤝

We welcome contributions! Here's how you can help:

1. **Fork the repository**
2. **Create a feature branch**: `git checkout -b feature/amazing-feature`
3. **Commit changes**: `git commit -m 'Add amazing feature'`
4. **Push to branch**: `git push origin feature/amazing-feature`
5. **Open a Pull Request**

### Contribution Guidelines

- Follow Noir coding conventions
- Update documentation as needed
- Use test data only (never real private keys)

## Roadmap 🗺️

Future enhancements may include:

- [ ] Support for different elliptic curves
- [ ] Batch signature verification
- [ ] Gas optimization for on-chain verification
- [ ] Integration with popular wallet libraries
- [ ] Performance benchmarking suite
- [ ] Additional signature schemes (Schnorr, BLS)

## Resources 📚

### Noir Documentation
- [Official Noir Docs](https://noir-lang.org/)
- [Noir Standard Library](https://noir-lang.org/docs/standard_library/cryptographic_primitives)
- [Elliptic Curve Operations](https://noir-lang.org/docs/standard_library/cryptographic_primitives/ec_operations)

### ECDSA and Cryptography
- [ECDSA Explained](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)
- [secp256k1 Curve](https://en.bitcoin.it/wiki/Secp256k1)
- [Zero-Knowledge Proofs](https://zkp.science/)

### Ethereum Development
- [Ethereum Signature Standards](https://eips.ethereum.org/EIPS/eip-191)
- [Foundry Anvil](https://book.getfoundry.sh/anvil/)

## License 📄

This project is licensed under the MIT License

## Acknowledgments 🙏

- **Noir Team** - For building an amazing ZK-DSL
- **Aztec Protocol** - For the Barretenberg proving system
- **Ethereum Foundation** - For ECDSA standards and tooling
- **Community Contributors** - For feedback and improvements

---

**🎉 Congratulations!** You've successfully generated and verified a zero-knowledge proof of ECDSA signature verification!

---

**Built with ❤️ using Noir • Star ⭐ if this helped you!**